"""
qutrit_clifford.py

This module defines the QutritCliffordGroup class for single-qutrit
(unencoded) Clifford operations. It generates the full set of
Clifford group expressions (as strings)
by combining the single-qutrit Pauli group with a mod-Pauli
subgroup generated via a Cayley graph.
"""

import cirq
import numpy as np
import re
import networkx as nx
from sympy.combinatorics import Permutation, PermutationGroup


class QutritCliffordGroup:
    """
    Generator for the unencoded single-qutrit Clifford group.

    The class builds Clifford expressions in two steps:
    1. Generate a mod-Pauli subgroup using permutations for `H` and `S`.
    2. Multiply that subgroup by the qutrit Pauli group to obtain the full
       expression set.

    Attributes:
        dimension (int): Local qudit dimension.
        P3Group (List[str]): Canonical qutrit Pauli expression set.
        C3modP3Group (List[str]): Mod-Pauli coset-representative expressions.
        full_group_expressions (List[str]): Full Clifford expression list.
        operation_map (Dict[str, cirq.Gate]): Primitive symbol-to-gate map for
            `I`, `X`, `Z`, `H`, `S`.
        ProductGate (Type): Product-gate constructor used in composition.

    Methods:
        __init__(dimension=3): Build all expression tables and base mappings.
        _generate_mod_pauli_group(): Build mod-Pauli subgroup expressions.
        _generate_full_group_expressions(): Compose full Clifford expressions.
        parse_and_multiply(expression): Parse one symbol/power expression.
        convert_strings_to_operations(expressions): Batch parse full strings.
        get_full_group_expressions(): Return full expression labels.
        get_group(): Return full group as gate objects.
    """

    def __init__(self, dimension: int = 3):
        """
        Initialize group tables and primitive gate mappings.
        
        Args:
            dimension (int): Local Hilbert-space dimension for the qudit system
                             represented by this operation.
        
        Returns:
        None: `__init__` updates internal object state and returns no value.
        
        Raises:
            ValueError: If supplied argument values violate this method's input
                        assumptions.
        """
        self.dimension = dimension
        # Define the Pauli group expressions.
        self.P3Group = ['I', 'X', 'Z', 'XZ',
                        'X^2', 'Z^2', 'X^2Z', 'Z^2X', 'X^2Z^2']
        # Generate the mod-Pauli subgroup via Cayley-graph traversal.
        self.C3modP3Group = self._generate_mod_pauli_group()
        # Combine the two parts to form the full Clifford group expressions.
        self.full_group_expressions = self._generate_full_group_expressions()
        # Map basic symbols to gate objects from gates.py.
        from gates import (
            ProductGate,
            QuditHadamard,
            QuditI,
            QuditS,
            QuditX,
            QuditZ,
        )
        self.operation_map = {
            'I': QuditI(dimension),
            'X': QuditX(dimension),
            'Z': QuditZ(dimension),
            'H': QuditHadamard(dimension),
            'S': QuditS(dimension)
        }
        self.ProductGate = ProductGate

    def _generate_mod_pauli_group(self):
        """
        Generate the mod-Pauli subgroup represented by `H`/`S` words.
        
        Args:
        None: `_generate_mod_pauli_group` relies on object state and accepts no
        additional inputs.
        
        Returns:
            object: Result object produced by this method.
        
        Raises:
        ValueError: If `_generate_mod_pauli_group` receives inputs that are
        incompatible with its expected configuration.
        """
        # Define generators corresponding to H and S.
        h_sym = Permutation([1, 2, 3, 0, 5, 7, 4, 6])
        s_sym = Permutation([4, 1, 7, 3, 6, 2, 0, 5])
        group = PermutationGroup([h_sym, s_sym])

        def caleyGraph(group):
            """
            Traverse the directed Cayley graph induced by subgroup generators.

            Args:
                group (PermutationGroup): Group generated by `H` and `S`
                    permutation generators.

            Returns:
                Tuple[nx.DiGraph, Dict[str, str]]: Graph structure and mapping
                from permutation-string nodes to generator-word labels.

            Raises:
                Exception: Propagates exceptions raised by underlying
                           operations,
                    dependencies, or invalid runtime states.
            """
            G = nx.DiGraph()
            identity = Permutation(list(range(8)))  # permutation of 8 elements
            nodeLabels = {str(identity): 'I'}
            nodesToProcess = [identity]
            # Breadth-first traversal over generator actions to recover a short
            # word label for each discovered permutation element.
            while nodesToProcess:
                perm = nodesToProcess.pop(0)
                permStr = str(perm)
                for gen, label in zip(group.generators, ['H', 'S']):
                    newPerm = perm * gen
                    newPermStr = str(newPerm)
                    if newPermStr not in nodeLabels:
                        newLabel = nodeLabels[permStr].replace('I', '') + label
                        nodeLabels[newPermStr] = newLabel
                        nodesToProcess.append(newPerm)
                    G.add_edge(permStr, newPermStr)
            return G, nodeLabels

        G, nodeLabels = caleyGraph(group)

        def mapToPowerNotation(seq):
            """
            Compress repeated generator symbols into power notation.

            Args:
                seq (str): Raw generator word such as `"HHSSS"`.

            Returns:
                str: Compacted expression such as `"H^2S^3"`.

            Raises:
                Exception: Propagates exceptions raised by underlying
                           operations,
                    dependencies, or invalid runtime states.
            """
            seq = re.sub(r'(H)\1+', lambda m: f'H^{len(m.group(0))}', seq)
            seq = re.sub(r'(S)\1+', lambda m: f'S^{len(m.group(0))}', seq)
            return seq

        modGroup = [mapToPowerNotation(label) for label in nodeLabels.values()]
        # Remove duplicates.
        modGroup = list(set(modGroup))
        return modGroup

    def _generate_full_group_expressions(self):
        """
        Build full Clifford expressions by combining Pauli and mod-Pauli parts.
        
        Args:
        None: `_generate_full_group_expressions` relies on object state and
        accepts no additional inputs.
        
        Returns:
            object: Result object produced by this method.
        
        Raises:
        ValueError: If `_generate_full_group_expressions` receives inputs that
        are incompatible with its expected configuration.
        """
        full_expressions = []
        # Build Cartesian product P3 x (C3 mod P3) and normalize expression
        # strings in identity edge-cases.
        for pauli in self.P3Group:
            for cliff in self.C3modP3Group:
                if pauli + cliff == 'II':
                    expr = 'I'
                elif cliff == 'I':
                    expr = pauli
                elif pauli == 'I':
                    expr = cliff
                else:
                    expr = pauli + cliff
                full_expressions.append(expr)
        # Remove duplicates and sort.
        full_expressions = sorted(list(set(full_expressions)))
        return full_expressions

    def parse_and_multiply(self, expression: str):
        """
Parse an expression like "H^2" or "S" and return the corresponding
unencoded gate.

Args:
    expression (str): Symbolic group expression string that will be parsed into
                      an executable circuit.

Returns:
    object: Output produced by this routine according to the behavior described
            above (parse an expression like "h^2" or "s" and return the
            corresponding).

Raises:
    KeyError: If this method encounters an invalid state while processing the
              provided inputs.
"""
        components = expression.split('^')
        base = components[0]
        exponent = 1
        if len(components) > 1:
            exponent = int(''.join(filter(str.isdigit, components[1])))
        if base not in self.operation_map:
            raise KeyError(f"Operation {base} not found.")
        result = self.operation_map[base]
        # Expand explicit powers through repeated gate composition.
        for _ in range(exponent - 1):
            result = result @ self.operation_map[base]
        return result

    def convert_strings_to_operations(self, expressions):
        """
        Parse a list of composite expression strings into gate objects.

        Args:
            expressions (List[str]): Clifford expression strings, potentially
                containing consecutive symbol/power blocks.

        Returns:
            List[cirq.Gate]: Parsed gate objects preserving input ordering.

        Raises:
            ValueError: If expression syntax is invalid.
        """
        results = []
        for expr in expressions:
            parts = []
            i = 0
            # Tokenize compact strings like "X^2ZHS^2" into symbol/power parts.
            while i < len(expr):
                if expr[i] in self.operation_map:
                    parts.append(expr[i])
                    i += 1
                elif expr[i] == '^':
                    if i + 1 < len(expr) and expr[i + 1].isdigit():
                        parts[-1] += expr[i]
                        i += 1
                        while i < len(expr) and expr[i].isdigit():
                            parts[-1] += expr[i]
                            i += 1
                    else:
                        raise ValueError(f"Invalid exponent syntax in {expr}")
                else:
                    raise ValueError(f"Unknown symbol in {expr}")
            if len(parts) == 1:
                results.append(self.parse_and_multiply(parts[0]))
            else:
                # Compose parsed parts in written order.
                res = self.parse_and_multiply(parts[0])
                for part in parts[1:]:
                    res = res @ self.parse_and_multiply(part)
                results.append(res)
        return results

    def get_full_group_expressions(self):
        """
        Returns the list of full (unencoded) Clifford group expressions as
        strings.
        
        Args:
        None: `get_full_group_expressions` relies on object state and accepts
        no additional inputs.
        
        Returns:
            object: Requested data object loaded or assembled by this method.
        
        Raises:
        ValueError: If `get_full_group_expressions` receives inputs that are
        incompatible with its expected configuration.
        """
        return self.full_group_expressions

    def get_group(self):
        """
        Returns a list of unencoded gates corresponding to the full Clifford
        group expressions.
        
        Args:
        None: `get_group` relies on object state and accepts no additional
        inputs.
        
        Returns:
            object: Requested data object loaded or assembled by this method.
        
        Raises:
        ValueError: If `get_group` receives inputs that are incompatible with
        its expected configuration.
        """
        ops = self.convert_strings_to_operations(self.full_group_expressions)
        return ops
